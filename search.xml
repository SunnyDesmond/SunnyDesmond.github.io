<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[vscode中使用tab emmet展开失效]]></title>
    <url>%2F2017%2F08%2F12%2Fvscode%E4%B8%AD%E4%BD%BF%E7%94%A8tab-emmet%E5%B1%95%E5%BC%80%E5%A4%B1%E6%95%88%2F</url>
    <content type="text"><![CDATA[问题用过vscode的同学都知道，这个文本编辑器异常强大。它提供了很多常用的插件，免除了在sublime中安装一堆插件的烦恼。尤其它自带的emmet，那是相当顺手。但是如果装了多了插件的话，有可能会把自带的emmet快捷键给冲突。造成tab形如ul&gt;li+span不能生成&lt;ul&gt;&lt;li&gt;&lt;/li&gt;&lt;span&gt;&lt;/span&gt;&lt;/ul&gt;这种尴尬的问题。 解决其实问题也是很好解决，只要按ctrl+p呼出控制器，然后输入keybindings.json按回车。它自动会跳转到keybindings.json页面，然后新增12345&#123; "key": "tab", "command": "-acceptSelectedSuggestion", "when": "config.emmet.triggerExpansionOnTab &amp;&amp; editorTextFocus &amp;&amp; !editorHasMultipleSelections &amp;&amp; !editorHasSelection &amp;&amp; !editorReadonly &amp;&amp; !editorTabMovesFocus"&#125; 就可以解决如上问题。P.S(如果已经存在tab，那就直接把command和when替换即可)。 如果想要键入ul&gt;li+span，让它后面自带提示的话，也非常简单，只要把12345&#123; "key": "tab", "command": "editor.emmet.action.expandAbbreviation", "when": "config.emmet.triggerExpansionOnTab &amp;&amp; editorTextFocus &amp;&amp; !editorHasMultipleSelections &amp;&amp; !editorHasSelection &amp;&amp; !editorReadonly &amp;&amp; !editorTabMovesFocus" &#125; 这个替换就行了。]]></content>
      <categories>
        <category>开发工具</category>
      </categories>
      <tags>
        <tag>vscode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于JQ的平滑滚动到顶部插件]]></title>
    <url>%2F2017%2F08%2F10%2F%E5%9F%BA%E4%BA%8EJQ%E7%9A%84%E5%B9%B3%E6%BB%91%E6%BB%9A%E5%8A%A8%E5%88%B0%E9%A1%B6%E9%83%A8%E6%8F%92%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[需求页面过长的时候，滑到底部之后要想再翻到网站的顶部查看内容，如果单纯依靠手指划显然不太友好。这时点击回到顶部的功能就显得非常人性化。 实现利用如下这段js，我们可以轻松的做到这一点。 123456789101112131415161718192021222324252627282930313233$.fn.scrollTo = function(options) &#123; var defaults = &#123; toT: 0, //滚动目标位置 durTime: 500, //过渡动画时间 delay: 30, //定时器时间 callback: null //回调函数 &#125;; var opts = $.extend(defaults, options), timer = null, _this = this, curTop = _this.scrollTop(), //滚动条当前的位置 subTop = opts.toT - curTop, //滚动条目标位置和当前位置的差值 index = 0, dur = Math.round(opts.durTime / opts.delay), smoothScroll = function(t) &#123; index++; var per = Math.round(subTop / dur); if (index &gt;= dur) &#123; _this.scrollTop(t); window.clearInterval(timer); if (opts.callback &amp;&amp; typeof opts.callback == 'function') &#123; opts.callback(); &#125; return; &#125; else &#123; _this.scrollTop(curTop + index * per); &#125; &#125;; timer = window.setInterval(function() &#123; smoothScroll(opts.toT); &#125;, opts.delay); return _this; &#125;; 最后我们只要给某一个按钮的点击事件里加上这个$(&quot;body&quot;).scrollTo({ toT: 0 });就ok了。]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[textarea高度自适应自动展开]]></title>
    <url>%2F2017%2F08%2F10%2FTEXTAREA%E9%AB%98%E5%BA%A6%E8%87%AA%E9%80%82%E5%BA%94%E8%87%AA%E5%8A%A8%E5%B1%95%E5%BC%80%2F</url>
    <content type="text"><![CDATA[需求web开发中，使用textarea的场景非常常见。但是原生的textarea不能根据用户输入的内容来伸缩自己的高度，这个特性感觉很反人类，在一些特定下我们希望它的高度能随着内容自适应，而不出现滚动条。就像下面的图一样。 demo图 实现代码 html 1&lt;textarea id="textarea"&gt;&lt;/textarea&gt; js 123456789101112131415161718192021222324252627282930313233343536 // textarea 自适应高度 function makeExpandingArea(el) &#123; var setStyle = function(el) &#123; el.style.height = 'auto'; el.style.height = el.scrollHeight + 'px'; // console.log(el.scrollHeight); &#125; var delayedResize = function(el) &#123; window.setTimeout(function() &#123; setStyle(el) &#125;, 0); &#125; if (el.addEventListener) &#123; el.addEventListener('input', function() &#123; setStyle(el) &#125;, false); setStyle(el) &#125; else if (el.attachEvent) &#123; el.attachEvent('onpropertychange', function() &#123; setStyle(el) &#125;); setStyle(el) &#125; if (window.VBArray &amp;&amp; window.addEventListener) &#123; //IE9 el.attachEvent("onkeydown", function() &#123; var key = window.event.keyCode; if (key == 8 || key == 46) delayedResize(el); &#125;); el.attachEvent("oncut", function() &#123; delayedResize(el); &#125;); //处理粘贴 &#125; &#125; makeExpandingArea(textarea);]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用FileReader实现图片上传预览]]></title>
    <url>%2F2017%2F08%2F10%2F%E4%BD%BF%E7%94%A8FileReader%E5%AE%9E%E7%8E%B0%E5%9B%BE%E7%89%87%E4%B8%8A%E4%BC%A0%E9%A2%84%E8%A7%88%2F</url>
    <content type="text"><![CDATA[需求web开发中经常会出现需要点击按钮然后上传图片这样的功能。一般我们会用第三方插件来实现。但其实如果需求不是很复杂的话，我们使用H5的FileReader就可以满足开发需求。 效果图 代码实现 html1234567&lt;div class="works-wrap"&gt; &lt;div class="figure-box" id="figure_box"&gt;&lt;/div&gt; &lt;div class="add-btn"&gt; &lt;input type="file" id="imgUploadBtn" /&gt; &lt;a href="javascript:void(0);"&gt;&lt;i&gt;&lt;/i&gt;添加作品&lt;/a&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; 啰嗦一下 我这边用css将input[type=file] 设置成了opticy:0; 这样可以看起来更像原生的上传。 js12345678910111213141516171819202122232425262728293031var addWork = &#123; add: function(btn, figure_box) &#123; var figureBox = document.getElementById(figure_box); //获取显示图片的div元素 var input = document.getElementById(btn); //获取选择图片的input元素 //这边是判断本浏览器是否支持这个API。 if (typeof FileReader === 'undefined') &#123; alert("浏览器版本过低，请先更新您的浏览器~"); input.setAttribute('disabled', 'disabled'); &#125; else &#123; input.addEventListener('change', readFile, false); //如果支持就监听改变事件，一旦改变了就运行readFile函数。 &#125; function readFile() &#123; var file = this.files[0]; //获取file对象 //判断file的类型是不是图片类型。 if (!/image\/\w+/.test(file.type)) &#123; alert("请上传一张图片~"); return false; &#125; var reader = new FileReader(); //声明一个FileReader实例 reader.readAsDataURL(file); //调用readAsDataURL方法来读取选中的图像文件 //最后在onload事件中，获取到成功读取的文件内容，并以插入一个img节点的方式显示选中的图片 reader.onload = function(e) &#123; // 创建一个新增的图片和文字input var figure = $('&lt;div class="figure"&gt;&lt;div class="figure-hd"&gt;我的头部&lt;/div&gt;&lt;div class="figure-bd"&gt;&lt;img src="' + this.result + '" /&gt;&lt;textarea placeholder="请输入文字"&gt;&lt;/textarea&gt;&lt;/div&gt;&lt;/div&gt;'); figure.appendTo(figureBox); &#125; &#125; &#125; &#125;]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[阻止页面滚动误触链接]]></title>
    <url>%2F2017%2F08%2F10%2F%E9%98%BB%E6%AD%A2%E9%A1%B5%E9%9D%A2%E6%BB%9A%E5%8A%A8%E8%AF%AF%E8%A7%A6%E9%93%BE%E6%8E%A5%2F</url>
    <content type="text"><![CDATA[问题描述最近在项目中遇到一个非常奇怪的问题，拿出来和大家分享一下。由于文采不好，原因又和这篇文章上描述的差不多，我这边就不组织语言了。直接copy过来了。原文地址 问题1、 在移动设备上快速滚动屏幕然后点击使滚动停止，如何尽量避免在点击时误触a标签，跳转到其他页？ 问题2、这也是在移动端的前端开发中实际遇到的一个问题，详细说来就是在正常情况下，当我们的当前页面内容较多，高度上较高，出现滚动条的时候，当我们用手滑动屏幕，屏幕上页面内容会快速滚动，不会因为手已经离开了屏幕而滚动停止。这个时候，当我们想要停止滚动的时候，我们也轻轻点击屏幕，让屏幕停止。但是这个时候有个问题，如果屏幕上点击的位置，正好有一个a标签，或者有一个button，这个时候就很容易进入下一个路由。查看了mdn上的关于scroll事件的一些说明，并没有对scroll过程中的速度和停止的反应时间这方面的说明。 解决办法找了好多文章没有具体的解决方案，后来在一篇文章的启发下，解决了这个问题。贴下代码：123456789101112131415161718192021$(function() &#123; //处理 滑动超长list的时候 click页面强行停止页面 可能会触发页面上的a链接 var count = 0, timer = null; var oldTop = newTop = $(window).scrollTop(); function log() &#123; if (timer) clearTimeout(timer); newTop = $(window).scrollTop(); console.log(++count, oldTop, newTop); if (newTop === oldTop) &#123;//页面停止做的操作 $("a").removeAttr("onclick"); clearTimeout(timer); &#125; else &#123; oldTop = newTop; timer = setTimeout(log, 100); $("a").attr("onclick", "return false"); //页面还在滚动中的操作 &#125; &#125; $(window).on('touchmove', log); &#125;); 实现原理原理就是，判断滚动的页面是否还在滚动中，如果滚动那就将点击元素return false禁止点击。反之放开点击操作。我这边好多页面路由跳转用的是a 的href，所以我这么写。大家如果可以用的话，也可以改成其他的标签。截图： 可以看到滚动中的页面 a标签上会有 禁止点击事件的操作。页面停止后，则删除这个禁止操作。 demo图]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css3实现switch button]]></title>
    <url>%2F2017%2F08%2F09%2Fcss3%E5%AE%9E%E7%8E%B0switch-button%2F</url>
    <content type="text"><![CDATA[需求switch button 在移动端上非常常见。如图： css3 实现现在我们用css3 来实现这个button。123&lt;div class="button-wrap"&gt; &lt;input type="checkbox"&gt; &lt;/div&gt; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364.button-wrap &#123; color: #999; &#125; .button-wrap input &#123; -webkit-tap-highlight-color: rgba(0, 0, 0, 0); -webkit-appearance: none; position: relative; width: 52px; height: 32px; border: 1px solid #dfdfdf; outline: 0; border-radius: 16px; box-sizing: border-box; background-color: #dfdfdf; -webkit-transition: background-color .1s, border .1s; transition: background-color .1s, border .1s; &#125; .button-wrap input:before &#123; content: " "; position: absolute; top: 0; left: 0; width: 50px; height: 30px; border-radius: 15px; background-color: #fdfdfd; -webkit-transition: -webkit-transform .35s cubic-bezier(.45, 1, .4, 1); transition: -webkit-transform .35s cubic-bezier(.45, 1, .4, 1); transition: transform .35s cubic-bezier(.45, 1, .4, 1); transition: transform .35s cubic-bezier(.45, 1, .4, 1), -webkit-transform .35s cubic-bezier(.45, 1, .4, 1); &#125; .button-wrap input:after &#123; content: " "; position: absolute; top: 0; left: 0; width: 30px; height: 30px; border-radius: 15px; background-color: #fff; box-shadow: 0 1px 3px rgba(0, 0, 0, .4); -webkit-transition: -webkit-transform .35s cubic-bezier(.4, .4, .25, 1.35); transition: -webkit-transform .35s cubic-bezier(.4, .4, .25, 1.35); transition: transform .35s cubic-bezier(.4, .4, .25, 1.35); transition: transform .35s cubic-bezier(.4, .4, .25, 1.35), -webkit-transform .35s cubic-bezier(.4, .4, .25, 1.35); &#125; .button-wrap input:checked &#123; border-color: #04be02; background-color: #04be02; &#125; .button-wrap input:checked:before &#123; -webkit-transform: scale(0); transform: scale(0); &#125; .button-wrap input:checked:after &#123; -webkit-transform: translateX(20px); transform: translateX(20px); &#125; 这种比较简洁，非常适合在移动端中使用。但是在pc上的话，我发现在chrome浏览器上是ok的。（ps：chrome真的是太流弊了~）在火狐上的话直接GG。IE 9也是可以的，只不过没有缓动动画。IE10正常，IE11貌似不行？？？？没细究。那接下来还有一种版本，兼容型不错。ie未测，FF还不错。123456&lt;div class="button-wrap-ff"&gt; &lt;label for="switchCP" class="switchCP"&gt; &lt;input type="checkbox" id="switchCP" checked="checked" class="switchCP-input"&gt; &lt;div class="switchCP-box"&gt;&lt;/div&gt; &lt;/label&gt; &lt;/div&gt; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677.button-wrap-ff &#123; color: #999; &#125; .switchCP &#123; -webkit-tap-highlight-color: rgba(0, 0, 0, 0); &#125; .switchCP&gt;* &#123; pointer-events: none; &#125; .switchCP-input &#123; -webkit-tap-highlight-color: rgba(0, 0, 0, 0); position: absolute; left: -9999px; &#125; .switchCP-input:checked~.switchCP-box &#123; border-color: #04be02; background-color: #04be02; &#125; .switchCP-input:checked~.switchCP-box:before &#123; -webkit-transform: scale(0); transform: scale(0); &#125; .switchCP-input:checked~.switchCP-box:after &#123; -webkit-transform: translateX(20px); transform: translateX(20px); &#125; .switchCP-box &#123; display: block; position: relative; width: 52px; height: 32px; border: 1px solid #dfdfdf; outline: 0; border-radius: 16px; box-sizing: border-box; background-color: #dfdfdf; -webkit-transition: background-color .1s, border .1s; transition: background-color .1s, border .1s; &#125; .switchCP-box:before &#123; content: " "; position: absolute; top: 0; left: 0; width: 50px; height: 30px; border-radius: 15px; background-color: #fdfdfd; -webkit-transition: -webkit-transform .35s cubic-bezier(.45, 1, .4, 1); transition: -webkit-transform .35s cubic-bezier(.45, 1, .4, 1); transition: transform .35s cubic-bezier(.45, 1, .4, 1); transition: transform .35s cubic-bezier(.45, 1, .4, 1), -webkit-transform .35s cubic-bezier(.45, 1, .4, 1); &#125; .switchCP-box:after &#123; content: " "; position: absolute; top: 0; left: 0; width: 30px; height: 30px; border-radius: 15px; background-color: #fff; box-shadow: 0 1px 3px rgba(0, 0, 0, .4); -webkit-transition: -webkit-transform .35s cubic-bezier(.4, .4, .25, 1.35); transition: -webkit-transform .35s cubic-bezier(.4, .4, .25, 1.35); transition: transform .35s cubic-bezier(.4, .4, .25, 1.35); transition: transform .35s cubic-bezier(.4, .4, .25, 1.35), -webkit-transform .35s cubic-bezier(.4, .4, .25, 1.35); &#125; ok，大功告成~]]></content>
      <categories>
        <category>css3</category>
      </categories>
      <tags>
        <tag>css3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[开篇]]></title>
    <url>%2F2017%2F08%2F09%2Fstart%2F</url>
    <content type="text"><![CDATA[一些废话恩，动手写个纯文字的博客还真是感觉挺麻烦的。毕竟我是一个懒人。首先标题取名字就让我很纠结。想了很久，感觉还是叫开篇比较好。毕竟本文就是写一些啰里啰嗦的流水文。而且是第一次用markdown书写，叫开篇自我感觉没毛病 &lt;(￣3￣)&gt; 。 一些过程博客的概念很早就知道了，但真正入坑还得从2015年说起。那时候查资料的时候总是能跳转到各种大牛的博客文章上去。而从这些文章中，也总能获取相关的知识，找到相关的问题的答案。感觉博客就是给人答题解难，自我提升的。羡慕之情，溢于言表。于是在工作不忙的时候，开始着手建立自己的博客。最开始接触的，自然是csdn。感觉各种方便。于是注册，建号，sunny_desmond,开始写一些自己在工作的中遇到的问题，感悟，感觉挺好。我是一个喜欢折腾的人。又在偶然机会看到可以搭建个人网站建立属于自己的博客。这想想就很酷啊。于是各种百度，google。然后注册域名，购买虚拟主机，备案。一顿操作后，我自己的博客终于诞生了。但由于新手，对建站知识很模糊，一开始买了一个windows系统的虚拟主机。然后发现只能跑.net的博客程序。。。没办法，谁让我买了一年的主机呢。然后用z-blog .net版搭建了第一个博客。resping。别问我域名为什么取这个名字，或者说这个域名有什么含义，因为我也不知道。。。49一年的主机真的是谁用谁知道。由于是windows系统且不支持php,我甚至不能搭建wordpress。然后终于在去年，把主机升级成了299一年的windows主机，她支持asp.net 和 php，于是，顺理成章的，博客从z-bolg换成了wp。接下来，使用wp跑了有大半年，中间没有出现问题。就在十几天前，老毛病又开始犯了。我觉得我的网站响应时间还是太慢了。TTFB很高。这不能忍，于是在一个风和日丽的清晨，我把站点连接到了七牛云存储。。然后各种坑，各种被镜像，各种无解。一怒之下，清空了数据库。。然后转投用hexo+github搭建了一个新的博客，新的起点开始了。。。。 一些后话说实话，markdown用起来很舒服，hexo博客用起来也很舒服。以前的博客文章我会慢慢迁移过来。新的随笔都会发布到这里。一直到。。github倒闭，或者出现新的博客系统为止。。。 感谢最后需要感谢一下网上一些大神的分享精神，解决了我很多开发中遇到的难题。当然，还要感谢一下我的老婆，感谢她支持我去折腾这些东西 &lt;(￣3￣)&gt;]]></content>
      <categories>
        <category>开篇</category>
      </categories>
      <tags>
        <tag>开篇</tag>
      </tags>
  </entry>
</search>
